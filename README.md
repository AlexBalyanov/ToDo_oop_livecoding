# Практика по ООП и MVP на примере приложения ToDo

Стек: HTML, SCSS, TS, Webpack

Структура проекта:
- src/ — исходные файлы проекта
- src/components/ — папка с JS компонентами
- src/components/base/ — папка с базовым кодом

Важные файлы:
- src/pages/index.html — HTML-файл главной страницы
- src/types/index.ts — файл с типами
- src/index.ts — точка входа приложения
- src/styles/styles.scss — корневой файл стилей
- src/utils/constants.ts — файл с константами
- src/utils/utils.ts — файл с утилитами

## Установка и запуск
Для установки и запуска проекта необходимо выполнить команды

```
npm install
npm run start
```

или

```
yarn
yarn start
```
## Сборка

```
npm run build
```

или

```
yarn build
```

## Заметки по практике

**_МОДЕЛЬ ДАННЫХ_** 
- сначала смотрим на макет, анализируем, какие есть данные, что с этими данными\
нужно делать и как хранить
- описываем интерфейсы для таких данных, при этом можно смотреть в коллекцию json
- если типы (интерфейсы) используются в разных частях проектах, то их нужно\
хранить отдельно, например, в папке types, а не конкретно в файле с классом
- думаем, какие методы (функционал) будет нужен для работы с этими данными
- описываем классы с полями и методами, при этом **НЕ нужно** дополнительно делать классы\
которые повторяют возвращаемые объекты json, такие объекты можно хранить в полях классов
- при описании данных думаем о том, **будто бы мы пишем сервер, где существуют только данные**\
и работа с ними
- всегда помнить о том, что данные хранятся на сервере в большинстве случаев\
от этого и нужно продумывать методы
- лучше максимально использовать композицию, например, класс Api не наследовать, а\
передавать в конструктор нужного класса и хранить Api в его поле (но тут сделано наследование)
- метод конструктора тоже наследуется с родителя, его можно не прописывать, если не нужно
- хорошая практика - передавать ТИП данных с помощью дженериков, который должен вернуть сервер

**_МОДЕЛЬ ПРЕДСТАВЛЕНИЯ_** 
- смотрим на макет с разметкой и анализируем, какие элементы являются интерактивными\
такие элементы нужно сохранять в полях класса для работы с ними
- нужно наследовать базовый класс Component для моделей представлений, он содержит\
основной функционал работы с разметкой
- конструктор класса должен принимать какой-то HTML контейнер, в котором\
затем можно будет найти все нужные нам элементы для работы, так же этот контейнер\
передаем аргументом в класс родитель (super) - Component
- все интерактивные элементы нужно искать в конструкторе, чтоб не дублировать\
поиск в методах класса
- менять интерактивные элементы можно при помощи **сеттеров**, а не отдельных методов
это самый правильный подход при отображении
- не забывать использовать методы утилитарных классов для работы с разметкой\
(ensureElement, cloneTemplate, toggleClass etc...)
- универсальный метод render() - использует Object.assign для того, чтоб перезаписывать\
наши свойства, сделанные **сеттерами**, частями или целиком, очень удобно\
можно передавать данные частями в виде объекта и перерисовывать элемент
- класс Page отвечает за главную страницу приложения, включает в себя общие\
динамические элементы страницы
- работа с классами представления по сути одна - определили элементы, которые должны\
реагировать/меняться в этом классе, создали для них поля, нашли их в конструкторе\,
сделали для них сеттеры, в этом же файле описали интерфейс для таких сеттеров\,
передали этот интерфейс в дженерик класса, чтоб дальше метод render() знал\,
с какими данными работать

**_МОДЕЛЬ УПРАВЛЕНИЯ (презентер)_** 
- в данном проекте в качестве презентера выступает корневой index.ts
- презентер создает экземпляры моделей и отображений и управляет их методами
- в данном примере при любом изменении данных происходит рендер всех карточек\
что не совсем правильно, для оптимизации нужно перерисовывать только конкретную\
часть интерфейса, а для этого нужно генерировать эмиттером разные события и\
обрабатывать их так же разными способами
- из классов представления можно передавать данные при генерации событий, например\
айди для дальнейшей работы именно с этой карточкой, эти данные принимаются в брокере\
в методе on
